using Microsoft.CodeAnalysis;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

using TuDog.IocAutoRegisterSourceGenerator.Models;

namespace TuDog.IocAutoRegisterSourceGenerator;

[Generator(LanguageNames.CSharp)]
public class AutoRegisterSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var projectFile = context.AdditionalTextsProvider
            .Where(x => x.Path.EndsWith(".csproj"))
            .Select((x, _) => x.GetText()).Combine(context.CompilationProvider);
        var content = projectFile.ToString();


        context.RegisterSourceOutput(projectFile, (context, proj) =>
        {

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(id: "Gen001",
                title: "Debug",
                messageFormat: $"开始启动源生成器"
                , category: "TuDog.SourceGenerator"
                , DiagnosticSeverity.Warning, isEnabledByDefault: true), Location.None));

            if ((proj.Left is null))
            {
                return;
            }
            var content = proj.ToString();

            //   Debugger.Launch();
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(id: "Gen002",
                title: "Debug",
                messageFormat: $"csproj文件为:{content}"
                , category: "TuDog.SourceGenerator"
                , DiagnosticSeverity.Warning, isEnabledByDefault: true), Location.None));

            string pattern = @"<ScanAssemblyRule>(.*?)<\/ScanAssemblyRule>";

            var rule = "*";
            var math = Regex.Match(content, pattern);
            if (math.Success)
            {
                rule = math.Groups[1].Value;
            }

            var models = DiscoverModel(proj.Right, rule);
            // 写文件
            if (models.Any())
            {
                var appNamespace = proj.Right.AssemblyName;
                if (string.IsNullOrEmpty(appNamespace))
                    return;


                var source = GenerateSource(models, appNamespace);

                context.AddSource("App.g.cs", source);

            }
        });




    }

    private static string GenerateSource(IEnumerable<DiscoverModel> models, string nameSpace)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine($"namespace {nameSpace}");
        sb.AppendLine("{");
        sb.AppendLine("public partial class App {");

        sb.AppendLine("protected override void AutoRegister(IServiceCollection collection){");

        foreach (var model in models)
        {

            var collection = "  collection.Add";
            if (model.LifeType == LifeType.Transient)
            {
                collection += "Transient";
            }
            else if (model.LifeType == LifeType.Scoped)
            {
                collection += "Scoped";
            }
            else
            {
                collection += "Singleton";
            }

            if (string.IsNullOrEmpty(model.InterfaceFullName))
            {
                sb.AppendLine($"{collection}<{model.ImplementFullName}>();");
            }
            else
            {
                sb.AppendLine($"{collection}<{model.InterfaceFullName},{model.ImplementFullName}>();");
            }
        }
        sb.AppendLine($"collection.AddSingleton<TuDog.Interfaces.IViewLocatorService,TuDog.Services.ViewLocatorService>();");

        sb.AppendLine("     }");

        sb.AppendLine(" }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static IEnumerable<DiscoverModel> DiscoverModel(Compilation compilation, string assemblyCondition)
    {

        var result = new List<DiscoverModel>();

        var main = FindClassesByAttribute(compilation.GlobalNamespace);
        if (main.Any())
            result.AddRange(main);
        return result;
    }

    private static IEnumerable<DiscoverModel> FindClassesByAttribute(IAssemblySymbol assembly)
    {
        return FindClassesByAttribute(assembly.GlobalNamespace);
    }

    private static IEnumerable<DiscoverModel> FindClassesByAttribute(INamespaceSymbol symbol)
    {
        var result = new List<DiscoverModel>();

        foreach (var type in GetNamespaceTypes(symbol))
        {

            if (type is { TypeKind: TypeKind.Class, IsAbstract: false } and var item)
            {
                if (item.GetAttributes().Length == 0)
                    continue;

                var att = item.GetAttributes().Select(x => x.AttributeClass?.OriginalDefinition.ToDisplayString());

                if (att is null)
                    continue;
                {
                    if (item.GetAttributes().FirstOrDefault(x => x.AttributeClass?.OriginalDefinition.ToDisplayString() == "TuDog.IocAttribute.RegisterAttribute<TService>") is { } find)
                    {
                        var model = new DiscoverModel();

                        var lifeTime = find.ConstructorArguments.FirstOrDefault().Value;
                        if (lifeTime is not null)
                        {
                            model.LifeType = (LifeType)lifeTime;
                        }

                        var interfaceType = find.AttributeClass?.TypeArguments[0].ToDisplayString();

                        model.InterfaceFullName = interfaceType;
                        model.ImplementFullName = item.ToDisplayString();
                        result.Add(model);
                        continue;
                    }
                }
                {
                    if (item.GetAttributes().FirstOrDefault(x => x.AttributeClass?.OriginalDefinition.ToDisplayString() == "TuDog.IocAttribute.RegisterAttribute") is { } find)
                    {
                        var model = new DiscoverModel();

                        foreach (var x in find.ConstructorArguments)
                        {
                            if (x.Type?.ToDisplayString() != "Microsoft.Extensions.DependencyInjection.ServiceLifetime")
                            {
                                continue;
                            }

                            model.LifeType = (LifeType)x.Value!;

                            model.ImplementFullName = item.ToDisplayString();
                            result.Add(model);
                            continue;
                        }
                    }
                }
            }

        }

        return result;
    }


    private static IEnumerable<INamedTypeSymbol> GetNamespaceTypes(INamespaceSymbol namespaceSymbol)
    {
        foreach (var member in namespaceSymbol.GetMembers())
        {
            if (member is INamespaceSymbol namespaceMember)
            {
                foreach (var nestedType in GetNamespaceTypes(namespaceMember))
                {
                    yield return nestedType;
                }
            }
            else if (member is INamedTypeSymbol typeMember)
            {
                yield return typeMember;
            }
        }
    }

}