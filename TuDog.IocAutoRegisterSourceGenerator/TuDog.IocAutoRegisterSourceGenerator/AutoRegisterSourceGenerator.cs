using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using TuDog.IocAutoRegisterSourceGenerator.Models;

namespace TuDog.IocAutoRegisterSourceGenerator;

[Generator(LanguageNames.CSharp)]
public class AutoRegisterSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var projectFile = context.AdditionalTextsProvider.Where(x => x.Path.EndsWith(".csproj")).Select((x, _) => x.GetText()).Combine(context.CompilationProvider);
        var content = projectFile.ToString();

        context.RegisterSourceOutput(projectFile, (context, proj) =>
        {
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("Gen001", "Debug", $"开始启动源生成器", "TuDog.SourceGenerator", DiagnosticSeverity.Warning, true), Location.None));

            if (proj.Left is null) return;
            var content = proj.ToString();

            //   Debugger.Launch();
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("Gen002", "Debug", $"csproj文件为:{content}", "TuDog.SourceGenerator", DiagnosticSeverity.Warning, true), Location.None));

            var pattern = @"<ScanAssemblyRule>(.*?)<\/ScanAssemblyRule>";

            var rule = "*";
            var math = Regex.Match(content, pattern);
            if (math.Success) rule = math.Groups[1].Value;

            var models = DiscoverModel(proj.Right, rule);
            // 写文件
            if (models.Any())
            {
                var appNamespace = proj.Right.AssemblyName;
                if (string.IsNullOrEmpty(appNamespace))
                    return;

                var source = GenerateSource(models, appNamespace);

                context.AddSource("App.g.cs", source);
            }
        });
    }

    private static string GenerateSource(IEnumerable<DiscoverModel> models, string nameSpace)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using DryIoc;");
        sb.AppendLine($"namespace {nameSpace}");
        sb.AppendLine("{");
        sb.AppendLine("public partial class App {");

        sb.AppendLine("protected override void AutoRegister(IContainer collection){");

        foreach (var model in models)
        {
            var collection = "  collection.Register";
            var registerType = "";

            if (model.LifeType == LifeType.Transient)
                registerType = "Reuse.Transient";
            else if (model.LifeType == LifeType.Scoped)
                registerType = "Reuse.Scoped";
            else
                registerType = "Reuse.Singleton";

            if (string.IsNullOrEmpty(model.InterfaceFullName))
                sb.AppendLine($"{collection}<{model.ImplementFullName}>({registerType});");
            else
                sb.AppendLine($"{collection}<{model.InterfaceFullName},{model.ImplementFullName}>({registerType});");
        }

        sb.AppendLine("collection.Register<TuDog.Interfaces.IViewLocatorService,TuDog.Services.ViewLocatorService>(Reuse.Singleton);");

        sb.AppendLine("     }");

        sb.AppendLine(" }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static IEnumerable<DiscoverModel> DiscoverModel(Compilation compilation, string assemblyCondition)
    {
        var result = new List<DiscoverModel>();

        var main = FindClassesByAttribute(compilation.GlobalNamespace);
        if (main.Any())
            result.AddRange(main);
        return result;
    }

    private static IEnumerable<DiscoverModel> FindClassesByAttribute(IAssemblySymbol assembly)
    {
        return FindClassesByAttribute(assembly.GlobalNamespace);
    }

    private static IEnumerable<DiscoverModel> FindClassesByAttribute(INamespaceSymbol symbol)
    {
        var result = new List<DiscoverModel>();

        foreach (var type in GetNamespaceTypes(symbol))
            if (type is { TypeKind: TypeKind.Class, IsAbstract: false } and var item)
            {
                if (item.GetAttributes().Length == 0)
                    continue;

                var att = item.GetAttributes().Select(x => x.AttributeClass?.OriginalDefinition.ToDisplayString());

                if (att is null)
                    continue;
                {
                    if (item.GetAttributes().FirstOrDefault(x => x.AttributeClass?.OriginalDefinition.ToDisplayString() == "TuDog.IocAttribute.RegisterAttribute<TService>") is { } find)
                    {
                        var model = new DiscoverModel();

                        var lifeTime = find.ConstructorArguments.FirstOrDefault().Value;
                        if (lifeTime is not null) model.LifeType = (LifeType)lifeTime;
                        else model.LifeType = LifeType.Transient;

                        var interfaceType = find.AttributeClass?.TypeArguments[0].ToDisplayString();

                        model.InterfaceFullName = interfaceType;
                        model.ImplementFullName = item.ToDisplayString();
                        result.Add(model);
                        continue;
                    }
                }
                {
                    if (item.GetAttributes().FirstOrDefault(x => x.AttributeClass?.OriginalDefinition.ToDisplayString() == "TuDog.IocAttribute.RegisterAttribute") is { } find)
                    {
                        var model = new DiscoverModel();

                        foreach (var x in find.ConstructorArguments)
                        {
                            if (x.Type?.ToDisplayString() != "TuDog.IocAttribute.ServiceLifetime") continue;

                            model.LifeType = (LifeType)x.Value!;

                            model.ImplementFullName = item.ToDisplayString();
                            result.Add(model);
                            continue;
                        }
                    }
                }
            }

        return result;
    }

    private static IEnumerable<INamedTypeSymbol> GetNamespaceTypes(INamespaceSymbol namespaceSymbol)
    {
        foreach (var member in namespaceSymbol.GetMembers())
            if (member is INamespaceSymbol namespaceMember)
                foreach (var nestedType in GetNamespaceTypes(namespaceMember))
                    yield return nestedType;
            else if (member is INamedTypeSymbol typeMember) yield return typeMember;
    }
}