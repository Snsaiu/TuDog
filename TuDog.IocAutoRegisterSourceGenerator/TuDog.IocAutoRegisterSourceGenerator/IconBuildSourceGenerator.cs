using System;
using Microsoft.CodeAnalysis;
using Newtonsoft.Json;
using System.Text;
using TuDog.IocAutoRegisterSourceGenerator.Models;

namespace TuDog.IocAutoRegisterSourceGenerator;

[Generator(LanguageNames.CSharp)]
public class IconBuildSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 找到指定路径的 AdditionalFile 并读取文本（使用 Ignore 大小写比较）
        var iconJsonProvider = context.AdditionalTextsProvider
            .Where(t => t.Path.EndsWith(@"Assets\IconFont\IconFont.json", StringComparison.OrdinalIgnoreCase))
            .Select((t, ct) => t.GetText(ct)?.ToString());

        var combined = iconJsonProvider.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(combined, (spc, pair) =>
        {
            spc.ReportDiagnostic(Diagnostic.Create("TuDogIconGen001", "Debug", $"pair.left:{pair.Left}",
                DiagnosticSeverity.Warning,
                DiagnosticSeverity.Warning, true, 1));

            var json = pair.Left;
            var compilation = pair.Right;
            if (string.IsNullOrEmpty(json))
                return;
            var escaped = json.Replace("\"", "\"\"");
            var result = new IconParseResultModel();
            result.NameSpace = compilation.AssemblyName ?? "Generated";
            result.ClassName = "IconFontProvider";
            var iconModel = JsonConvert.DeserializeObject<IconModel>(json);
            result.Icons = iconModel;
            GenerateSourceAsync(spc, result);
        });
    }

    private static void GenerateSourceAsync(SourceProductionContext ctx, IconParseResultModel? ct)
    {
        if (ct is not { Icons: not null and var data })
        {
            ctx.ReportDiagnostic(Diagnostic.Create("TuDogIconGen001", "Debug", "没有找到图标信息", DiagnosticSeverity.Warning,
                DiagnosticSeverity.Warning, true, 1));
            return;
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"namespace {ct.NameSpace};");
        sb.AppendLine($"public static class {ct.ClassName}{{");

        foreach (var item in data.glyphs)
        {
            sb.AppendLine("///<summary>");
            sb.AppendLine($"///{item.name}");
            sb.AppendLine("///</summary>");
            sb.AppendLine($"public const string {item.font_class} = \"\\u{item.unicode}\";");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        ctx.AddSource($"{ct.ClassName}.g.cs", sb.ToString());
    }
}