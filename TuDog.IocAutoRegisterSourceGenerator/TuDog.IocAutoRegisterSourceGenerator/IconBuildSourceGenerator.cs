using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using Newtonsoft.Json;

using System.Net.Http;
using System.Text;

using TuDog.IocAutoRegisterSourceGenerator.Models;

namespace TuDog.IocAutoRegisterSourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class IconBuildSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {


            var provider = context.SyntaxProvider.CreateSyntaxProvider((node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                 (ctx, _) => GetClassDeclaration(ctx));

            context.RegisterSourceOutput(provider, GenerateSourceAsync);

        }


        private static void GenerateSourceAsync(SourceProductionContext ctx, IconParseResultModel? ct)
        {
            if (ct is not { Icons: not null and var data })
                return;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine($"namespace {ct.NameSpace};");
            sb.AppendLine($"public static class {ct.ClassName}Builder{{");

            foreach (var item in data.glyphs)
            {
                sb.AppendLine("///<summary>");
                sb.AppendLine($"///{item.name}");
                sb.AppendLine("///</summary>");
                sb.AppendLine($"public const string {item.font_class} = \"\\u{item.unicode}\";");
                sb.AppendLine();
            }
            sb.AppendLine("}");

            ctx.AddSource($"{ct.ClassName}Builder.g.cs", sb.ToString());

        }

        private static IconParseResultModel? GetClassDeclaration(GeneratorSyntaxContext context)
        {
            var classSyntax = (ClassDeclarationSyntax)context.Node;

            var result = new IconParseResultModel();

            foreach (var item in classSyntax.AttributeLists)
            {
                foreach (var attribute in item.Attributes)
                {
                    var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                    if (symbol is null)
                        return null;

                    if (symbol.ContainingType.ToDisplayString() == "TuDog.IocAttribute.IconBuildAttribute")
                    {

                        if (attribute.ArgumentList?.Arguments.Count != 1)
                            return null;

                        var nameSpaceSymbol = context.SemanticModel.GetDeclaredSymbol(classSyntax) as INamedTypeSymbol;
                        result.NameSpace = nameSpaceSymbol?.ContainingNamespace?.ToString() ?? string.Empty;
                        if (string.IsNullOrEmpty(result.NameSpace))
                            return null;

                        result.ClassName = classSyntax.Identifier.Text;
                        if (string.IsNullOrEmpty(result.ClassName))
                            return null;

                        var p = attribute.ArgumentList!.Arguments.First();

                        var exp = context.SemanticModel.GetConstantValue(p.Expression);
                        if (!exp.HasValue)
                            return null;

                        var jsonUrl = exp.Value!.ToString();

                        //int index = 0;
                        //foreach (var arg in attribute.ArgumentList!.Arguments)
                        //{
                        //    if (index == 0)
                        //    {
                        //        jsonUrl = 
                        //    }
                        //    else if (index == 1)
                        //    {
                        //        downloadUrl = context.SemanticModel.GetConstantValue(arg.Expression).Value.ToString();
                        //    }
                        //    else if (index == 2)
                        //    {
                        //        result.DownloadPath = context.SemanticModel.GetConstantValue(arg.Expression).Value.ToString();
                        //        continue;
                        //    }
                        //    index++;
                        //}

                        var httpClient = new HttpClient();
                        var json = httpClient.GetStringAsync(jsonUrl).GetAwaiter().GetResult();

                        var iconModel = JsonConvert.DeserializeObject<IconModel>(json);

                        if (iconModel is null)
                            return null;

                        result.Icons = iconModel;



                        return result;
                    }
                }
            }
            return null;
        }
    }
}
