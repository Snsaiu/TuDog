using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Newtonsoft.Json;
using System.Net.Http;
using System.Text;
using TuDog.IocAutoRegisterSourceGenerator.Models;

namespace TuDog.IocAutoRegisterSourceGenerator;

[Generator(LanguageNames.CSharp)]
public class IconBuildSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 找到指定路径的 AdditionalFile 并读取文本（使用 Ignore 大小写比较）
        var iconJsonProvider = context.AdditionalTextsProvider.Where(t => t.Path.EndsWith(@"Assets\IconFont\IconFont.json", StringComparison.OrdinalIgnoreCase)).Select((t, ct) => t.GetText(ct)?.ToString());

        var combined = iconJsonProvider.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(combined, (spc, pair) =>
        {
            var json = pair.Left;
            var compilation = pair.Right;
            if (string.IsNullOrEmpty(json))
                return;
            var escaped = json.Replace("\"", "\"\"");
            var result = new IconParseResultModel();
            result.NameSpace = compilation.AssemblyName ?? "Generated";
            result.ClassName = "IconFontProvider";
            var iconModel = JsonConvert.DeserializeObject<IconModel>(json);
            result.Icons = iconModel;
            GenerateSourceAsync(spc, result);
        });

        var provider = context.SyntaxProvider.CreateSyntaxProvider((node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0, (ctx, _) => GetClassDeclaration(ctx));
        context.RegisterSourceOutput(provider, GenerateSourceAsync);
    }

    private static void GenerateSourceAsync(SourceProductionContext ctx, IconParseResultModel? ct)
    {
        if (ct is not { Icons: not null and var data })
            return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"namespace {ct.NameSpace};");
        sb.AppendLine($"public static class {ct.ClassName}{{");

        foreach (var item in data.glyphs)
        {
            sb.AppendLine("///<summary>");
            sb.AppendLine($"///{item.name}");
            sb.AppendLine("///</summary>");
            sb.AppendLine($"public const string {item.font_class} = \"\\u{item.unicode}\";");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        ctx.AddSource($"{ct.ClassName}.g.cs", sb.ToString());
    }

    private static IconParseResultModel? GetClassDeclaration(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;

        var result = new IconParseResultModel();

        foreach (var item in classSyntax.AttributeLists)
        foreach (var attribute in item.Attributes)
        {
            var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
            if (symbol is null)
                return null;

            if (symbol.ContainingType.ToDisplayString() == "TuDog.IocAttribute.IconBuildAttribute")
            {
                if (attribute.ArgumentList?.Arguments.Count != 1)
                    return null;

                var nameSpaceSymbol = context.SemanticModel.GetDeclaredSymbol(classSyntax) as INamedTypeSymbol;
                result.NameSpace = nameSpaceSymbol?.ContainingNamespace?.ToString() ?? string.Empty;
                if (string.IsNullOrEmpty(result.NameSpace))
                    return null;

                result.ClassName = classSyntax.Identifier.Text;
                if (string.IsNullOrEmpty(result.ClassName))
                    return null;

                var p = attribute.ArgumentList!.Arguments.First();

                var exp = context.SemanticModel.GetConstantValue(p.Expression);
                if (!exp.HasValue)
                    return null;

                var jsonUrl = exp.Value!.ToString();

                //int index = 0;
                //foreach (var arg in attribute.ArgumentList!.Arguments)
                //{
                //    if (index == 0)
                //    {
                //        jsonUrl = 
                //    }
                //    else if (index == 1)
                //    {
                //        downloadUrl = context.SemanticModel.GetConstantValue(arg.Expression).Value.ToString();
                //    }
                //    else if (index == 2)
                //    {
                //        result.DownloadPath = context.SemanticModel.GetConstantValue(arg.Expression).Value.ToString();
                //        continue;
                //    }
                //    index++;
                //}
                var httpClient = new HttpClient();
                var json = httpClient.GetStringAsync(jsonUrl).GetAwaiter().GetResult();

                var iconModel = JsonConvert.DeserializeObject<IconModel>(json);

                if (iconModel is null)
                    return null;

                result.Icons = iconModel;

                return result;
            }
        }

        return null;
    }
}